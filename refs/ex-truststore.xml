<truststore
  xmlns="urn:ietf:params:xml:ns:yang:ietf-truststore"
  xmlns:or="urn:ietf:params:xml:ns:yang:ietf-origin"
  xmlns:ct="urn:ietf:params:xml:ns:yang:ietf-crypto-types">

  <!-- A bag of Certificate Bags -->
  <certificate-bags or:origin="or:intended">

    <!-- Manufacturer's Trusted Root CA Certs (in <operational>)-->
    <certificate-bag or:origin="or:system">
      <name>manufacturers-root-ca-certs</name>
      <description>
        Certificates built into the device for authenticating
        manufacturer-signed objects, such as TLS server certificates,
        vouchers, etc.  Note, though listed here, these are not
        configurable; any attempt to do so will be denied.
      </description>
      <certificate>
        <name>Manufacturer Root CA cert 1</name>
        <cert>base64encodedvalue==</cert>
      </certificate>
      <certificate>
        <name>Manufacturer Root CA cert 2</name>
        <cert>base64encodedvalue==</cert>
      </certificate>
    </certificate-bag>
  
    <!-- CA Certs for Public (e.g., Internet-based) HTTPS Servers -->
    <certificate-bag>
      <name>common-ca-certs</name>
      <description>
        Trust anchors (i.e. CA certs) used to authenticate server
        certificates.  A server certificate is authenticated if its
        end-entity certificate has a chain of trust to one of these
        certificates.
      </description>
      <certificate>
        <name>Go Daddy Class 2 Certification Authority</name>
        <cert>base64encodedvalue==</cert>
      </certificate>
      <certificate>
        <name>VeriSign Universal Root Certification Authority</name>
        <cert>base64encodedvalue==</cert>
      </certificate>
    </certificate-bag>

    <!-- CA Certs for Authenticating Servers Using Private PKIs -->
    <certificate-bag>
      <name>trusted-server-ca-certs</name>
      <description>
        Trust anchors (i.e. CA certs) used to authenticate server
        certificates.  A server certificate is authenticated if its
        end-entity certificate has a chain of trust to one of these
        certificates.
      </description>
      <certificate>
        <name>Server Cert Issuer #1</name>
        <cert>base64encodedvalue==</cert>
      </certificate>
      <certificate>
        <name>Server Cert Issuer #2</name>
        <cert>base64encodedvalue==</cert>
      </certificate>
    </certificate-bag>
  
    <!-- Pinned End Entity Certs for Authenticating Servers -->
    <certificate-bag>
      <name>trusted-server-ee-certs</name>
      <description>
        Specific end-entity certificates used to authenticate server
        certificates.  A server certificate is authenticated if its
        end-entity certificate is an exact match to one of these
        certificates.
      </description>
      <certificate>
        <name>My Application #1</name>
        <cert>base64encodedvalue==</cert>
      </certificate>
      <certificate>
        <name>My Application #2</name>
        <cert>base64encodedvalue==</cert>
      </certificate>
    </certificate-bag>
  
    <!-- CA Certs for Authenticating Clients -->
    <certificate-bag>
      <name>trusted-client-ca-certs</name>
      <description>
        Trust anchors (i.e. CA certs) used to authenticate client
        certificates.  A client certificate is authenticated if its
        end-entity certificate has a chain of trust to one of these
        certificates.
      </description>
      <certificate>
        <name>Client Identity Issuer #1</name>
        <cert>base64encodedvalue==</cert>
      </certificate>
      <certificate>
        <name>Client Identity Issuer #2</name>
        <cert>base64encodedvalue==</cert>
      </certificate>
    </certificate-bag>
  
    <!-- Pinned End Entity Certs for Authenticating Clients -->
    <certificate-bag>
      <name>trusted-client-ee-certs</name>
      <description>
        Specific end-entity certificates used to authenticate client
        certificates.  A client certificate is authenticated if its
        end-entity certificate is an exact match to one of these
        certificates.
      </description>
      <certificate>
        <name>George Jetson</name>
        <cert>base64encodedvalue==</cert>
      </certificate>
      <certificate>
        <name>Fred Flintstone</name>
        <cert>base64encodedvalue==</cert>
      </certificate>
    </certificate-bag>
  </certificate-bags>


  <!-- A Bag of SSH Host Key Bags -->
  <ssh-public-key-bags or:origin="or:intended">

    <!-- SSH Host Keys for Authenticating SSH Servers -->
    <ssh-public-key-bag>
      <name>trusted-ssh-public-keys</name>
      <description>
        Specific SSH public keys used to authenticate SSH server
        public keys.  An SSH server public key is authenticated if
        its public key is an exact match to one of these public keys.

        This list of SSH public keys is analogous to OpenSSH's
        "/etc/ssh/ssh_known_hosts" file.
      </description>
      <ssh-public-key>
        <name>corp-fw1</name>
        <algorithm>secp256r1</algorithm>
        <public-key-format>ct:ssh-public-key-format</public-key-format>
        <public-key>base64encodedvalue==</public-key>
      </ssh-public-key>
      <ssh-public-key>
        <name>corp-fw2</name>
        <algorithm>secp256r1</algorithm>
        <public-key-format>ct:ssh-public-key-format</public-key-format>
        <public-key>base64encodedvalue==</public-key>
      </ssh-public-key>
    </ssh-public-key-bag>

    <!-- SSH Host Keys for Authenticating User A -->
    <ssh-public-key-bag>
      <name>SSH Public Keys for User A</name>
      <description>
        SSH public keys used to authenticate a user A's SSH public
        keys.  An SSH public key is authenticated if it is an exact
        match to one of these public keys.

        This list of public keys is analogous to OpenSSH's
        "~A/.ssh/authorized_keys" file.
      </description>
      <ssh-public-key>
        <name>From Source #1</name>
        <algorithm>secp256r1</algorithm>
        <public-key-format>ct:ssh-public-key-format</public-key-format>
        <public-key>base64encodedvalue==</public-key>
      </ssh-public-key>
      <ssh-public-key>
        <name>From Source #2</name>
        <algorithm>secp256r1</algorithm>
        <public-key-format>ct:ssh-public-key-format</public-key-format>
        <public-key>base64encodedvalue==</public-key>
      </ssh-public-key>
    </ssh-public-key-bag>

    <!-- SSH Host Keys for Authenticating User B -->
    <ssh-public-key-bag>
      <name>SSH Public Keys for User B</name>
      <description>
        SSH public keys used to authenticate a user A's SSH public
        keys.  An SSH public key is authenticated if it is an exact
        match to one of these public keys.

        This list of public keys is analogous to OpenSSH's
        "~B/.ssh/authorized_keys" file.
      </description>
      <ssh-public-key>
        <name>From Source #1</name>
        <algorithm>secp256r1</algorithm>
        <public-key-format>ct:ssh-public-key-format</public-key-format>
        <public-key>base64encodedvalue==</public-key>
      </ssh-public-key>
      <ssh-public-key>
        <name>From Source #2</name>
        <algorithm>secp256r1</algorithm>
        <public-key-format>ct:ssh-public-key-format</public-key-format>
        <public-key>base64encodedvalue==</public-key>
      </ssh-public-key>
    </ssh-public-key-bag>
  </ssh-public-key-bags>


  <!-- A Bag of Raw Public Key Bags -->
  <raw-public-key-bags or:origin="or:intended">

    <!-- Raw Public Keys for FIXME... -->
    <raw-public-key-bag>
      <name>Raw Public Keys for FIXME 1</name>
      <description>
        FIXME...
      </description>
      <raw-public-key>
        <name>Raw Public Key #1</name>
        <algorithm>rsa2048</algorithm>
        <public-key-format>ct:subject-public-key-info-format</public-key-format>
        <public-key>base64encodedvalue==</public-key>
      </raw-public-key>
      <raw-public-key>
        <name>Raw Public Key #2</name>
        <algorithm>rsa2048</algorithm>
        <public-key-format>ct:subject-public-key-info-format</public-key-format>
        <public-key>base64encodedvalue==</public-key>
      </raw-public-key>
    </raw-public-key-bag>

    <!-- Raw Public Keys for FIXME... -->
    <raw-public-key-bag>
      <name>Raw Public Keys for FIXME 2</name>
      <description>
        FIXME...
      </description>
      <raw-public-key>
        <name>Raw Public Key #1</name>
        <algorithm>rsa2048</algorithm>
        <public-key-format>ct:subject-public-key-info-format</public-key-format>
        <public-key>base64encodedvalue==</public-key>
      </raw-public-key>
      <raw-public-key>
        <name>Raw Public Key #2</name>
        <algorithm>rsa2048</algorithm>
        <public-key-format>ct:subject-public-key-info-format</public-key-format>
        <public-key>base64encodedvalue==</public-key>
      </raw-public-key>
    </raw-public-key-bag>
  </raw-public-key-bags>

</truststore>
